#!/usr/bin/env perl

# this requires nerd-fonts, and proper terminal configuation
# font cheat sheet: https://www.nerdfonts.com/cheat-sheet

use 5.012;
use strict;
use warnings;
use utf8;
use open ":std", ":encoding(UTF-8)";
use experimental qw(signatures);

use Data::Dumper::Concise;
use Getopt::Long;
Getopt::Long::Configure(qw(no_ignore_case));
use Pod::Usage;

use Cwd qw(abs_path getcwd);
use File::Basename;
use File::cd;
use File::Slurper qw(read_text);
use POSIX qw(strftime);

# read defaults from ~/.config/lls/*
foreach my $args_file ( map { "$ENV{HOME}/.config/lls/$_" }
    "args",
    "${^O}_args"
) {
    if(open(my $default_args_file, '<', $args_file)) {
        (my $opts = join(' ', <$default_args_file>)) =~ s/^\s+|\s+$//g;
        unshift(@ARGV, split(/\s+/, $opts));
        close($default_args_file);
    }
}

# implement bundling of single char args like -lAR. While Getopt::Long can
# optionally do this it's incompatible with `--foo bar baz` style multi-arg
# opts
my @new_argv = ();
while(@ARGV) {
    my $this_arg = shift(@ARGV);
    if($this_arg eq '--') {
        push @new_argv, $this_arg, @ARGV;
        last;
    } elsif($this_arg =~ /^-[^-]/) {
        my @unbundled = split('', $this_arg);
        push @new_argv, map { "-$_" } @unbundled[1 .. $#unbundled];
    } else {
        push @new_argv, $this_arg;
    }
}
@ARGV = @new_argv;

# finally after all that throat-clearing we can parse the command line.
# first, die on errors
$SIG{__WARN__} =sub {
    die(@_, "\nTry -h for help\n") if($_[0] =~ /^Unknown option: /);
    warn(@_);
};
# make sure these exist so we can reference them
my %opt_show = map { $_ => 0 } qw(
    perms links owner group size date icons name
);
GetOptions(
    'long|l'     => \my $opt_long,
    'all|a'      => \my $opt_all,
    'hidden|A'   => \my $opt_hidden,
    'dirs|d'     => \my $opt_dirs,
    'reverse|r'  => \my $opt_reverse,
    'time|t'     => \my $opt_time,
    'size|S'     => \my $opt_size,
    'recurse|R'  => \my $opt_recurse,
    'norecurse=s' => \my @opt_no_recurse,
    'git|g'      => \my $opt_git,
    'ascii|7'    => \my $opt_ascii,
    'utf8|8'     => \my $opt_utf8,
    'ignore|I=s' => \my @opt_ignore,
    'iso8601'    => \my $opt_iso8601,
    'noiso8601'  => \my $opt_noiso8601,
    'noicons'    => \my $opt_noicons,
    'help|h|?'   => \my $help,
    'HELP|H'     => \my $HELP,
    # defaults
    show_icons => \$opt_show{icons},
    show_name  => \$opt_show{name},
    # turned on with -l
    show_perms => \$opt_show{perms},
    show_links => \$opt_show{links},
    show_owner => \$opt_show{owner},
    show_group => \$opt_show{group},
    show_size  => \$opt_show{size},
    show_date  => \$opt_show{date},
    # type maps
    'ext_type=s{2}'  => \my @opt_ext_types,
    'name_type=s{2}' => \my @opt_name_types,
    'default_types'  => \my $opt_default_types,
    'show_default_types' => \my $opt_show_default_types,
    # icon types
    'icon_type=s{2}' => \my @opt_icon_types,
    'default_icons'  => \my $opt_default_icons,
    'show_default_icons' => \my $opt_show_default_icons,
    # debuggery, undocumented
    'show_all_args'  => sub { say $_ foreach(@new_argv); exit 1; },
);

# now post-process args

# first, with these we can just spit some output and stop
if($help) { pod2usage(0) }
if($HELP) { pod2usage({-exitval => 0, -verbose => 2}) }
if($opt_show_default_types) {
    my %defaults = default_file_types();
    foreach my $name_part (sort keys %defaults) {
        foreach my $type (sort keys %{$defaults{$name_part}}) {
            foreach my $name (@{$defaults{$name_part}->{$type}}) {
                say "--${name_part}_type $type $name";
            }
        }
    }
}
if($opt_show_default_icons) {
    my %defaults = default_icon_types();
    foreach my $type (sort keys %defaults) {
        say "--icon_type $type $defaults{$type}";
    }
}
exit(0) if($opt_show_default_types || $opt_show_default_icons);

# some things imply other things
$opt_ascii   = 0 if($opt_utf8);
$opt_noicons = 1 if($opt_ascii);
$opt_iso8601 = 0 if($opt_noiso8601);

# some options are incompatible with each other
if($opt_noicons && $opt_show{icons}) {
    die "\n--noicons and --show_icons makes no sense\n\n";
}

# defaults for which columns to display
if(!grep { $_ } values(%opt_show)) {
    # the user didn't set any of these so we can
    if($opt_long) {
        $opt_show{$_}++ foreach (keys(%opt_show));
    } else {
        @opt_show{qw(icons name)} = (1, 1);
    }
}
# these columns are controlled by other args
$opt_show{git}   = $opt_git;
$opt_show{tree}  = $opt_recurse;
$opt_show{icons} = 0 if($opt_noicons);

# transmogrify the lists of {name,ext}/type pairs into a more
# useful data structure
my %opt_type;
if(!@opt_ext_types && !@opt_name_types) {
    %opt_type = default_file_types();
} else {
    if($opt_default_types) { %opt_type = default_file_types(); }
    while(@opt_name_types) {
        my($name, $type) = splice(@opt_name_types, 0, 2);
        $opt_type{name}->{$type} ||= [];
        push @{$opt_type{name}->{$type}}, $name;
    }
    while(@opt_ext_types) {
        my($ext, $type) = splice(@opt_ext_types, 0, 2);
        $opt_type{ext}->{$type} ||= [];
        push @{$opt_type{ext}->{$type}}, $ext;
    }
}
# likewise for type/icon pairs
my %opt_icon;
if(!@opt_icon_types) {
    %opt_icon = default_icon_types();
} else {
    %opt_icon = (
        ($opt_default_icons ? default_icon_types(): ()),
        @opt_icon_types
    );
}

# clean up trailing / and multiple // in --ignore and --norecurse,
# and parse $FIGNORE
@opt_ignore = map { s/\/+$//; s/\/+/\//rg } map {
    $_ eq '$FIGNORE' ? (grep { length } split(':', $ENV{FIGNORE})) : $_
} @opt_ignore;
@opt_no_recurse = map { s/\/+$//; s/\/+/\//rg } @opt_no_recurse;

# finally, we're ready to go
my @targets = map { s{/+$}{}r } sortfiles(@ARGV);
@targets = ('.') unless(@targets);
my @output_lines;
my @last;
work_on(0, @targets);

# some columns have variable width, we need to figure out how much is needed
my @line_max_sizes = ();
foreach my $line (grep { ref($_) } @output_lines) {
    foreach my $index (1, 2, 3) {
        $line_max_sizes[$index] = length($line->[$index]) if(
            !defined($line_max_sizes[$index]) ||
            length($line->[$index]) > $line_max_sizes[$index]
        )
    }
}
my $format = $opt_show{perms} ? '%s' : '';
$format   .= $opt_show{links} ? ' %'.($line_max_sizes[1] + 1).'d' : '';
$format   .= $opt_show{owner} ? ' %'.($line_max_sizes[2] + 1).'s' : '';
$format   .= $opt_show{group} ? ' %'.($line_max_sizes[3] + 1).'s' : '';
$format   .= $opt_show{size}  ? ' %6s' : '';
$format   .= $opt_show{date}  ? ' %s'  : '';
$format   .= $opt_show{icons} ? ' %s'  : '';
$format   .= $opt_show{git}   ? ' %s'  : '';
$format   .= $opt_show{tree}  ? '%s'   : ''; # no space cos tree art always has one
$format   .= $opt_show{name}  ? ' %s'  : '';
$format =~ s/^ //;

foreach my $line (@output_lines) {
    if(!ref($line)) {
        say $line;
    } else {
        say sprintf($format, @{$line});
    }
}

sub work_on ($depth, @targets) {
    my $have_already_rendered;
    my $prev_rendered_was_dir;
    foreach my $target (@targets) {
        if(-d $target && ($opt_recurse || !$opt_dirs)) {
            if($#targets > 0) {
                push @output_lines, "" if($have_already_rendered);
                push @output_lines, "$target:";
            }
    
            if($opt_recurse && !$depth) {
                $opt_recurse = 0;
                push @output_lines, build_data(0, $target);
                $opt_recurse = 1;
            }
            cd $target => sub {
                $prev_rendered_was_dir = 1;
                opendir(my $dh, '.') || die("Couldn't read $target: $!\n");
                my @dirents = grep {
                    # if --dirs not in effect, return everything
                    !$opt_dirs ||
                    # otherwise only return dirs if $opt_recurse in effect
                    ($opt_recurse && -d $_)
                } grep {
                    my $candidate = $_;
                    !grep {
                        $candidate eq $_                        ||
                        abs_path('.')."/$candidate" eq $_       ||
                        ($_ =~ /^\./ && $candidate =~ /\Q$_\E/)
                    } @opt_ignore
                } sortfiles(readdir($dh));
                while(@dirents) {
                    my $dirent = shift(@dirents);
                    $last[$depth] = !@dirents;
                    next if($dirent =~ /^\.\.?$/ && (($opt_recurse && $depth + 1) || !$opt_all));
                    next if($dirent =~ /^\./     && !($opt_all || $opt_hidden));
    
                    push @output_lines, build_data($depth, $dirent);
                    work_on($depth + 1, $dirent)
                        if($opt_recurse && !-l $dirent && -d $dirent && !grep {
                            $dirent eq $_ ||
                            abs_path('.')."/$dirent" eq $_
                        } @opt_no_recurse);
                }
                closedir($dh);
            };
        } else {
            push @output_lines, "" if($prev_rendered_was_dir);
            push @output_lines, build_data($depth, $target);
            $prev_rendered_was_dir = 0;
        }
        $have_already_rendered = 1;
    }
}

sub build_data ($depth, $dirent) {
    my $icons    = get_icons($dirent =~ /^\// ? $dirent : abs_path('.')."/$dirent");
    my $filename = get_colourized_filename($dirent);

    return [
        $opt_show{perms}    ? format_mode(cached_stat($dirent)->[2]) : (),
        $opt_show{links}    ? cached_stat($dirent)->[3] : (),
        $opt_show{owner}    ? (getpwuid(cached_stat($dirent)->[4]))[0] : (),
        $opt_show{group}    ? (getgrgid(cached_stat($dirent)->[5]))[0] : (),
        $opt_show{size}     ? format_size(cached_stat($dirent)->[7]) : (),
        $opt_show{date}     ? strftime(
            ( $opt_iso8601                                      ? '%Y-%m-%d %H:%M' :
              time - cached_stat($dirent)->[9] < 60*60*24*365/2 ? "%d %b %H:%M" :
                                                                  "%d %b  %Y"
            ),
            (localtime(cached_stat($dirent)->[9]))[0 .. 5]
        ) : (),
        $opt_show{icons}    ? $icons : (),
        $opt_show{git}      ? format_git($dirent) : (),
        $opt_show{tree}     ? (
            $opt_recurse ? format_tree_art($depth) : ''
        ) : (),
        $opt_show{name} ? join(' ',
            $filename, (-l $dirent ? ('->', readlink($dirent)) : ())
        ) : (),
    ];
}

my %git_cache;
sub format_git ($dirent) {
    return '  ' if($dirent eq '.git');
    my $what_to_check = $dirent =~ /^\// ? $dirent : abs_path('.');
    $git_cache{$what_to_check} ||= `git status -s --ignored=matching $what_to_check 2>/dev/null`;
    return '  ' if(!$git_cache{$what_to_check});

    # See https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-status.html for
    # what [AMRUD] and friends mean
    my %git_info = map {
        substr($_, 3) => substr($_, 0, 2)
                         =~ tr/AMRUD/+±?-/r
                         =~ s/(!!|\?\?)/$1 eq '!!' ? 'Ig' : 'Un'/er
    } split(/\n/, $git_cache{$what_to_check});
    return $git_info{$dirent} if(exists($git_info{$dirent}));

    if(-d $dirent) {
        my @candidates = grep { /^\Q$dirent\E\// } keys %git_info;
        my %statuses = map { $_ => 1 } @git_info{@candidates};
        if((keys %statuses) == 1) { return keys %statuses } # all changes in children are the same
        elsif((keys %statuses) == 0) { return '  ' }        # no changes in children
         else { return '..' }                               # mixture
    }

    return '  ';
}


sub format_tree_art ($depth) {
    my $art = '';
    foreach my $index ( 0 .. $depth - 1 ) {
        if($last[$index]) {
            $art .= '   '
        } else {
            $art .= ' │ '
        }
    }
    if($last[$depth]) {
        $art .= ' └─'
    } else {
        $art .= ' ├─'
    }
    $art =~ y/│├└─/|+\\-/ if($opt_ascii);
    return $art;
}

sub format_size ($size) {
    my @multipliers = qw(B K M G T);
    while($size > 1024) {
        $size >>= 10;
        shift @multipliers
    }
    return join(' ', $size, shift(@multipliers));
}

# lovingly stolen from https://metacpan.org/release/BDFOY/PerlPowerTools-1.025/source/bin/ls
sub format_mode ($mode) {
    my @perms = qw(--- --x -w- -wx r-- r-x rw- rwx);
    my @ftype = ('', qw(p c ? d ? b ? - ? l ? s ? ? ?));
    my $setids = ($mode & 07000)>>9;
    my @permstrs = @perms[($mode&0700)>>6, ($mode&0070)>>3, $mode&0007];
    my $ftype = $ftype[($mode & 0170000)>>12];
   
    if ($setids) {
        if ($setids & 01) {             # Sticky bit
            $permstrs[2] =~ s/([-x])$/$1 eq 'x' ? 't' : 'T'/e;
        }
        if ($setids & 04) {             # Setuid bit
            $permstrs[0] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e;
        }
        if ($setids & 02) {             # Setgid bit
            $permstrs[1] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e;
        }
    }
   
    join '', $ftype, @permstrs;
}

sub sortfiles (@files) {
    my $sorter = sorter();
    @files = sort {
       $sorter->($a, $b) || ($a cmp $b)
    } @files;
    
    if($opt_reverse) { return reverse @files }
     else { return @files }
}

sub sorter {
    no warnings 'uninitialized';
    $opt_time ? sub ($l, $r) {
                 (cached_stat($r)->[9] || ~0) <=> (cached_stat($l)->[9] || ~0)
             } :
    $opt_size ? sub ($l, $r) {
                 (cached_stat($r)->[7]) <=> (cached_stat($l)->[7])
             } :
             sub { 0 }
}

my %stat_cache;
sub cached_stat ($filename) {
    $filename = $filename =~ /^\// ? $filename : abs_path('.')."/$filename";

    return $stat_cache{$filename} if(exists($stat_cache{$filename}));
    return $stat_cache{$filename} = [lstat($filename)];
}

sub get_colourized_filename ($filename) {
    state $ls_command = `ls --version 2>/dev/null` ? 'ls -d --color=always' :
                        `uname` =~ /Darwin/        ? 'CLICOLOR_FORCE=1 ls -dG' :
                                                     'ls -d';

    my $rendered_filename = -t STDOUT 
        ? `$ls_command "$filename"`
        : $filename;
    chomp($rendered_filename);
    return $rendered_filename;
}

sub get_icon_type_specific {
    my $original_filename = shift();
    my $filename = basename($original_filename);
    (my $ext = $filename) =~ s/^.*\.//;
    $ext = '' if($ext eq $filename);
    return (
        ( grep {
            my $type = $_;
            grep {
                $_ eq $filename ||
                ( -d $filename && $_ eq "/$filename") ||
                (
                    -d $original_filename &&
                    /^\/\// &&
                    -e "$original_filename/".(s/^\/\///r)
                )
            } @{$opt_type{name}->{$type}};
        } keys %{$opt_type{name}} ),
        ( grep {
            my $type = $_;
            grep { $_ eq $ext } @{$opt_type{ext}->{$type}};
        } keys %{$opt_type{ext}} ),
        ''
    )[0];
}

sub get_icon_type_generic ($filename) {
    return
        -l $filename ? ( do {
            my $target = readlink($filename);
            my $target_type = get_icon_type_generic($target);
            !-e $target                     ? 'linkbroken' :
            $target_type eq 'dir'           ? 'linkdir'  :
            $target_type =~ /^(file|exec)$/ ? 'linkfile' :
                                              'link'
        } ) :
        -d $filename ? 'dir'      :
        -x $filename ? 'exec'     :
        -f $filename ? 'file'     :
        -p $filename ? 'pipe'     :
        -S $filename ? 'socket'   :
        -b $filename ? 'blockdev' :
        -c $filename ? 'chardev'  :
                       ''; # WTF!?!?!?
}

sub get_icons ($filename) {
    my $generic  = get_icon_type_generic($filename);
    my $specific = get_icon_type_specific($filename);

    return join(' ', ($opt_icon{$generic} || ' '), ($opt_icon{$specific} || ' '));
}

sub default_icon_types {
    (
        # unix dirent types
        link       => '',
        linkbroken => '',
        linkfile   => '',
        linkdir    => '',
        dir        => '',
        exec       => '',
        file       => '',
        pipe       => 'ﳣ',
        socket     => 'ﳦ',
        blockdev   => '',
        chardev    => '',

        apple      => '',
        c          => '',
        'c++'      => '',
        ci         => '',
        data       => '',
        git        => '',
        golang     => '',
        haskell    => '',
        html       => '',
        java       => '',
        javascript => '',
        lisp       => '',
        list       => '',
        lock       => '',
        object     => '',
        perl       => '',
        php        => '',
        python     => '',
        ruby       => '',
        rust       => '',
        test       => '',
        text       => '',
        tree       => 'פּ',
        vim        => '',
    )
}

sub default_file_types {
    ( 
        ext  => {
            'c++'      => ['cpp'],
            c          => [qw(c h)],
            data       => [qw(yml json)],
            golang     => [qw(go)],
            haskell    => [qw(hs)],
            html       => [qw(htm html)], 
            java       => [qw(java)],
            javascript => [qw(js)],
            lisp       => [qw(lsp lisp el elc)],
            lock       => ['lock'],
            object     => [qw(bs o)],
            perl       => [qw(pl pm PL xs)],
            php        => [qw(php)],
            python     => [qw(py pyc pyo)],
            ruby       => [qw(rb)],
            rust       => [qw(rs rlib)],
            test       => ['t'],
            text       => [qw(md txt)],
            vim        => ['swp'],
        },
        name => {
            apple  => [qw(.AppleDB .AppleDouble .DS_Store)],
            ci     => [qw(.appveyor.yml .cirrus.yml)],
            exec   => [qw(/bin)],
            git    => [qw(.github .gitignore .git //.git)],
            list   => [qw(MANIFEST MANIFEST.SKIP CHANGES CHANGELOG Changes Changelog)],
            object => [qw(/blib)],
            test   => [qw(/t)],
            tree   => [qw(cpanfile Makefile Makefile.PL)],
        }
    )
}

=encoding utf8

=head1 NAME

lls - a differently capable and much more configurable `ls`

=head1 SYNOPSIS

  $ lls [OPTIONS] [FILES]

=head1 DEPENDENCIES

A Unixy operating system.

You will need to install C<Nerd Font>. See its instructions on Github:
L<https://github.com/ryanoasis/nerd-fonts/blob/master/readme.md>.

You will then need to configure your terminal appropriately. If you use
iTerm on a Mac then see these instructions:
L<https://github.com/Peltoche/lsd/issues/199#issuecomment-494218334>.
If you are not using iTerm on a Mac then you are computering wrong.

=head1 OPTIONS

=over

=item -l | --long

Turns on all the available columns. Without any other options this will be the
same as C<ls -l> but with an extra column of icons before the filenames.

See also L</"DISPLAY OPTIONS"> and L</"FILE TYPES AND ICONS">.

=item -a | --all

Show all directory entries. The default is to suppress any whose names
begin with a dot.

=item -A | --hidden

Show all directory entries except C<.> and C<..>. C<-a> over-rides this.

=item -I | --ignore FILE

Takes an argument, the name of a file to ignore. That file will not be
listed, including if a file with that name exists in a subdir and C<-R>
is in effect. To only ignore a specific file and not any other files with
the same name provide its fully qualified absolute path. If FILE begins with
a dot then any file with that extension will be ignored.

This option can be supplied many times.

As a special case, you can pass C<-I $FIGNORE> (that's the literal string
'$FIGNORE' - you'll probably have to escape the dollar sign). That will ignore
everything in the C<FIGNORE> environment variable.

=item -d | --dirs

If a directory name is given on the command line show its metadata, not
its contents.

In conjunction with C<-R> recurses into subdirs and only shows directories.

=item -r | --reverse

Reverse sort order

=item -t | --time

Sort output by modified-time

=item -S | --size

Sort output by size

=item -R | --recurse

Recurse into sub-directories. The output is very different from what C<ls> does.
Compare:

    $ ls -lR a
    total 0
    drwxr-xr-x  3 david  staff  102  2 Jul 12:44 b
    
    a/b:
    total 0
    drwxr-xr-x  3 david  staff  102  2 Jul 12:44 c
    
    a/b/c:
    total 0
    drwxr-xr-x  2 david  staff  68  2 Jul 12:44 d
    
    a/b/c/d:

and:

    $ lls -lR a
    drwxr-xr-x  3  david  staff  102 B 02 Jul 12:44    a
    drwxr-xr-x  3  david  staff  102 B 02 Jul 12:44    └─ b
    drwxr-xr-x  3  david  staff  102 B 02 Jul 12:44       └─ c
    drwxr-xr-x  2  david  staff   68 B 02 Jul 12:44          └─ d

=item --norecurse DIR

Takes an argument, the name of a directory to not recurse into even
when C<-R> is turned on. Like C<--ignore> can be either a name that
exists in any directory, or a fully-qualified name, and can be supplied
many times.

=item -g | --git

Include information on files' git status.

=item --noicons

Suppress icons output. Incompatible with C<--show_icons>.

=item --iso8601

Show date/time in ISO 8601:2004 format

=item --noiso8601

Turn off C<--iso8601>. This is the default.

=item -7 | --ascii

Suppress non-ASCII output. Implies C<--noicons>. If you ask for recursive
output the tree will be rendered in ASCII.

=item -8 | --utf8

Use Unicode (encoded as utf-8) for output. This is the default. Over-rides any
C<--ascii>, and does so before that has a chance to suppress icons.

=item -H | --HELP (all caps)

Show more help

=back

=head1 DISPLAY OPTIONS

The default with no options is to show files' icons and names in one long
list. With the
C<-l> option you get permissions, number of links, owner, group, size,
date/time, icons, and names. With the C<-R> option a tree will be added,
and with the C<-g> option git info will be added.

But it's a lot more configurable than that. If any of the following options
are present then all of the other display options will be turned off and C<-l>
will have no effect:

=over

=item --show_icons

Show the icons for a file. There will always be at least one icon, and
sometimes two.

See L</"FILE TYPES AND ICONS"> for more details.

=item --show_name

Show the filename

=item --show_perms

Show the read/write/execute permissions and file type

=item --show_links

Show the number of links to the file

=item --show_owner

Show the file's owner

=item --show_group

Show the file's group

=item --show_size

Show the file's size. NB that this is shown as the number of
bytes/KiB/MiB/GiB/TiB.

=item --show_date

Show the file's last modified date/time.

=back

=head1 FILE TYPES AND ICONS

File types and icon type maps are used to divine what icons to show for a file.

The first icon is determined by whether the file is a symlink (and if it is
whether it is a link to a file, a directory, something else, or is broken), a
directory, an executable file, any other kind of file, a pipe, a socket, a
block device, or a character device. These type names and their default icons
are shown below:

    link         
    linkbroken   
    linkdir      
    linkfile     
    dir          
    executable   
    file         
    pipe         ﳣ
    socket       ﳦ
    blockdev     
    chardev      

The second icon is determined based on the filename, file extension, or whether
a directory contains a particular filename. There are some vaguely sensible
defaults built in, but you can control them using the following command line
arguments.

=over

=item --ext_type EXTENSION TYPE

map files with extension EXTENSION to type TYPE, unless the file's entire name
matches something specified using C<--name_type>. If this is specified all the
defaults are turned off unless you explicitly turn them back on. Can be used
multiple times.

=item --name_type FILENAME TYPE

map files with name FILENAME to type TYPE. If this is specified all the
defaults are turned off unless you explicitly turn them back on. Can be used
multiple times.

If the FILENAME begins with a C</> then the type will only be applied to directories
with that name.

If the FILENAME begins with two slashes C<//> then the type will only be applied
to directories that contain a file with that name.

=item --default_types

Turn on all the defaults. If you are inclined to provide your own C<--name_type>s
or C<--ext_type>s then I suggest that you put this in your config file.

=item --show_default_types

Spit out all the defaults and immediately exit.

=back

You can control which icons are associated with each type thus:

=over

=item --icon_type TYPE ICON

map any file with type TYPE to icon ICON. If this is specified all the defaults
are turned off unless you explicitly turn them back on. Can be used multiple times.
ICON should be a single character, and the display will go all wibbly if it isn't
a single width character. However, no checks are made in this regard.

=item --default_icons

Turn on all the defaults. If you are inclined to provide your own C<--icon_type>s
then I suggest that you put this in your config file.

=item --show_default_icons

Spit out all the defaults and immediately exit.

=back

=head1 FILES

Default arguments will be read from C<~/.config/lls/args> if it exists.
Platform-specific arguments will be read from C<~/.config/lls/${platform}_args>
if it exists.
