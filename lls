#!/usr/bin/env perl

use 5.012;
use strict;
use warnings;
use utf8;
use open ":std", ":encoding(UTF-8)";
use experimental qw(signatures);

use Getopt::Long;
Getopt::Long::Configure('bundling');
use Pod::Usage;

use Cwd qw(abs_path);
use File::Basename;
use File::cd;
use File::Slurper qw(read_text);
use POSIX qw(strftime);

# this requires nerd-fonts, and proper terminal configuation
# font cheat sheet: https://www.nerdfonts.com/cheat-sheet

my %opt_show = map { $_ => 0 } qw(
    perms links owner group size date icons name
);
foreach my $args_file ( map { "$ENV{HOME}/.config/lls/$_" }
    "args",
    "${^O}_args"
) {
    if(open(my $default_args_file, '<', $args_file)) {
        (my $opts = join(' ', <$default_args_file>)) =~ s/^\s+|\s+$//g;
        unshift(@ARGV, split(/\s+/, $opts));
        close($default_args_file);
    }
}
$SIG{__WARN__} =sub {
    die(@_, "\nTry -h for help\n") if($_[0] =~ /^Unknown option: /);
    warn(@_);
};
GetOptions(
    'long|l'     => \my $opt_long,
    'all|a'      => \my $opt_all,
    'hidden|A'   => \my $opt_hidden,
    'dirs|d'     => \my $opt_dirs,
    'reverse|r'  => \my $opt_reverse,
    'time|t'     => \my $opt_time,
    'size|S'     => \my $opt_size,
    'recurse|R'  => \my $opt_recurse,
    'norecurse=s' => \my @opt_no_recurse,
    'git|g'      => \my $opt_git, # FIXME NYI
    'ascii|7'    => \my $opt_ascii,
    'utf8|8'     => \my $opt_utf8,
    'ignore|I=s' => \my @opt_ignore,
    'noicons'    => \my $opt_noicons,
    'help|h|?'   => \my $help,
    'HELP|H'     => \my $HELP,
    # defaults
    show_icons => \$opt_show{icons},
    show_name  => \$opt_show{name},
    # turned on with -l
    show_perms => \$opt_show{perms},
    show_links => \$opt_show{links},
    show_owner => \$opt_show{owner},
    show_group => \$opt_show{group},
    show_size  => \$opt_show{size},
    show_date  => \$opt_show{date},
);
$opt_ascii   = 0 if($opt_utf8);
$opt_noicons = 1 if($opt_ascii);

if($opt_noicons && $opt_show{icons}) {
    die "\n--noicons and --show_icons makes no sense\n\n";
}
if(!grep { $_ } values(%opt_show)) {
    # the user didn't set any of these so we can
    if($opt_long) {
        $opt_show{$_}++ foreach (keys(%opt_show));
    } else {
        @opt_show{qw(icons name)} = (1, 1);
    }
}
$opt_show{git}   = $opt_git;
$opt_show{tree}  = $opt_recurse;
$opt_show{icons} = 0 if($opt_noicons);

@opt_ignore = map { s/\/+$//; s/\/+/\//rg } map {
    $_ eq '$FIGNORE' ? (grep { length } split(':', $ENV{FIGNORE})) : $_
} @opt_ignore;
@opt_no_recurse = map { s/\/+$//; s/\/+/\//rg } @opt_no_recurse;

my @targets = map { s{/+$}{}r } sortfiles(@ARGV);
@targets = ('.') unless(@targets);

if($help) { pod2usage(0) }
if($HELP) { pod2usage({-exitval => 0, -verbose => 2}) }

my @output_lines;
my @last;
work_on(0, @targets);

my @line_max_sizes = ();
foreach my $line (grep { ref($_) } @output_lines) {
    foreach my $index (1, 2, 3) {
        $line_max_sizes[$index] = length($line->[$index]) if(
            !defined($line_max_sizes[$index]) ||
            length($line->[$index]) > $line_max_sizes[$index]
        )
    }
}
my $format = '';
$format .= $opt_show{perms}    ? '%s' : '';
$format .= $opt_show{links}    ? ' %'.($line_max_sizes[1] + 1).'d' : '';
$format .= $opt_show{owner}    ? ' %'.($line_max_sizes[2] + 1).'s' : '';
$format .= $opt_show{group}    ? ' %'.($line_max_sizes[3] + 1).'s' : '';
$format .= $opt_show{size}     ? ' %6s'  : '';
$format .= $opt_show{date}     ? ' %12s' : '';
$format .= $opt_show{icons}    ? ' %s'   : '';
$format .= $opt_show{git}      ? ' %s'   : '';
$format .= $opt_show{tree}     ? '%s'    : ''; # no space cos tree art always has one
$format .= $opt_show{name}  ? ' %s'   : '';
$format =~ s/^ //;

foreach my $line (@output_lines) {
    if(!ref($line)) {
        say $line;
    } else {
        say sprintf($format, @{$line});
    }
}

sub work_on ($depth, @targets) {
    my $have_already_rendered;
    my $prev_rendered_was_dir;
    foreach my $target (@targets) {
        if(-d $target && ($opt_recurse || !$opt_dirs)) {
            if($#targets > 0) {
                push @output_lines, "" if($have_already_rendered);
                push @output_lines, "$target:";
            }
    
            if($opt_recurse && !$depth) {
                $opt_recurse = 0;
                push @output_lines, build_data(0, $target);
                $opt_recurse = 1;
            }
            cd $target => sub {
                $prev_rendered_was_dir = 1;
                opendir(my $dh, '.') || die("Couldn't read $target: $!\n");
                my @dirents = grep {
                    # if --dirs not in effect, return everything
                    !$opt_dirs ||
                    # otherwise only return dirs if $opt_recurse in effect
                    ($opt_recurse && -d $_)
                } grep {
                    my $candidate = $_;
                    !grep {
                        $candidate eq $_                        ||
                        abs_path('.')."/$candidate" eq $_       ||
                        ($_ =~ /^\./ && $candidate =~ /\Q$_\E/)
                    } @opt_ignore
                } sortfiles(readdir($dh));
                while(@dirents) {
                    my $dirent = shift(@dirents);
                    $last[$depth] = !@dirents;
                    next if($dirent =~ /^\.\.?$/ && ($depth + 1 || !$opt_all));
                    next if($dirent =~ /^\./     && !($opt_all || $opt_hidden));
    
                    push @output_lines, build_data($depth, $dirent);
                    work_on($depth + 1, $dirent)
                        if($opt_recurse && !-l $dirent && -d $dirent && !grep {
                            $dirent eq $_ ||
                            abs_path('.')."/$dirent" eq $_
                        } @opt_no_recurse);
                }
                closedir($dh);
            };
        } else {
            push @output_lines, "" if($prev_rendered_was_dir);
            push @output_lines, build_data($depth, $target);
            $prev_rendered_was_dir = 0;
        }
        $have_already_rendered = 1;
    }
}

sub build_data ($depth, $dirent) {
    my $icons    = get_icons($dirent =~ /^\// ? $dirent : abs_path('.')."/$dirent");
    my $filename = get_colourized_filename($dirent);

    return [
        $opt_show{perms}    ? format_mode(cached_stat($dirent)->[2]) : (),
        $opt_show{links}    ? cached_stat($dirent)->[3] : (),
        $opt_show{owner}    ? (getpwuid(cached_stat($dirent)->[4]))[0] : (),
        $opt_show{group}    ? (getgrgid(cached_stat($dirent)->[5]))[0] : (),
        $opt_show{size}     ? format_size(cached_stat($dirent)->[7]) : (),
        $opt_show{date}     ? strftime(
            (time - cached_stat($dirent)->[9] < 60*60*24*365/2 ? "%d %b %H:%M" : "%d %b  %Y"),
            (localtime(cached_stat($dirent)->[9]))[0 .. 5]
        ) : (),
        $opt_show{icons}    ? $icons : (),
        $opt_show{git}      ? "--" : (),
        $opt_show{tree}     ? (
            $opt_recurse ? format_tree_art($depth) : ''
        ) : (),
        $opt_show{name} ? join(' ',
            $filename, (-l $dirent ? ('->', readlink($dirent)) : ())
        ) : (),
    ];
}

sub format_tree_art ($depth) {
    my $art = '';
    foreach my $index ( 0 .. $depth - 1 ) {
        if($last[$index]) {
            $art .= '   '
        } else {
            $art .= ' │ '
        }
    }
    if($last[$depth]) {
        $art .= ' └─'
    } else {
        $art .= ' ├─'
    }
    $art =~ y/│├└─/|+\\-/ if($opt_ascii);
    return $art;
}

sub format_size ($size) {
    my @multipliers = qw(B K M G T);
    while($size > 1024) {
        $size >>= 10;
        shift @multipliers
    }
    return join(' ', $size, shift(@multipliers));
}

# lovingly stolen from https://metacpan.org/release/BDFOY/PerlPowerTools-1.025/source/bin/ls
sub format_mode ($mode) {
    my @perms = qw(--- --x -w- -wx r-- r-x rw- rwx);
    my @ftype = ('', qw(p c ? d ? b ? - ? l ? s ? ? ?));
    my $setids = ($mode & 07000)>>9;
    my @permstrs = @perms[($mode&0700)>>6, ($mode&0070)>>3, $mode&0007];
    my $ftype = $ftype[($mode & 0170000)>>12];
   
    if ($setids) {
        if ($setids & 01) {             # Sticky bit
            $permstrs[2] =~ s/([-x])$/$1 eq 'x' ? 't' : 'T'/e;
        }
        if ($setids & 04) {             # Setuid bit
            $permstrs[0] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e;
        }
        if ($setids & 02) {             # Setgid bit
            $permstrs[1] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e;
        }
    }
   
    join '', $ftype, @permstrs;
}

sub sortfiles (@files) {
    my $sorter = sorter();
    @files = sort {
       $sorter->($a, $b) || ($a cmp $b)
    } @files;
    
    if($opt_reverse) { return reverse @files }
     else { return @files }
}

sub sorter {
    no warnings 'uninitialized';
    $opt_time ? sub ($l, $r) {
                 (cached_stat($r)->[9] || ~0) <=> (cached_stat($l)->[9] || ~0)
             } :
    $opt_size ? sub ($l, $r) {
                 (cached_stat($r)->[7]) <=> (cached_stat($l)->[7])
             } :
             sub { 0 }
}

my %stat_cache;
sub cached_stat ($filename) {
    $filename = $filename =~ /^\// ? $filename : abs_path('.')."/$filename";

    return $stat_cache{$filename} if(exists($stat_cache{$filename}));
    return $stat_cache{$filename} = [lstat($filename)];
}

sub get_colourized_filename ($filename) {
    state $ls_command = `ls --version 2>/dev/null` ? 'ls -d --color=always' :
                        `uname` =~ /Darwin/        ? 'CLICOLOR_FORCE=1 ls -dG' :
                                                     'ls -d';

    my $rendered_filename = -t STDOUT 
        ? `$ls_command "$filename"`
        : $filename;
    chomp($rendered_filename);
    return $rendered_filename;
}

sub get_icon_type_specific {
    my $filename = basename(shift());
    (my $ext = $filename) =~ s/^.*\.//;
    $ext = '' if($ext eq $filename);
    return
        $filename eq 'cpanfile'                 ? 'tree'   :
        $ext      eq 'c'                              ? 'c'      :
        $ext      eq 'cpp'                            ? 'c++'    :
        $ext      eq 'h'                              ? 'header' :
        $ext      eq 't'                              ? 'test'   :
        $ext      eq 'txt'                            ? 'text'   :
        $ext      eq 'swp'                            ? 'vim'    :
        $ext      eq 'lock'                           ? 'lock'   :
        $filename =~ /^Makefile(\.PL)?$/          ? 'tree'   :
        $filename =~ /^\.git(hub|ignore)?$/       ? 'git'    :
        $filename =~ /^\.(Apple(DB|Double)|DS_Store)$/ ? 'apple'  :
        $filename =~ /^\.(appveyor|cirrus)\.yml$/ ? 'ci'     :
        $filename =~ /^change(s|log)$/i           ? 'list'   :
        $filename =~ /^MANIFEST(\.SKIP)?$/        ? 'list'   :
        $filename =~ /\.(xs|p[lm]|PL)$/                  ? 'perl'   :
        $filename =~ /\.(bs|o)$/                         ? 'object' :
                                                           '';
}

sub get_icon_type_generic ($filename) {
    return
        -l $filename ? 'link'     :  # must be first
        -d $filename ? 'dir'      :
        -x $filename ? 'exec'     :
        -f $filename ? 'file'     :
        -p $filename ? 'pipe'     :
        -S $filename ? 'socket'   :
        -b $filename ? 'blockdev' :
        -c $filename ? 'chardev'  :
                       ''; # WTF!?!?!?
}

sub get_icons ($filename) {
    my $generic  = get_icon_type_generic($filename);
    my $specific = get_icon_type_specific($filename) || (
        ($generic eq 'dir'  && basename($filename) eq 't'         ) ? 'test'   :
        ($generic eq 'dir'  && basename($filename) eq 'bin'       ) ? 'exec'   :
        ($generic eq 'dir'  && basename($filename) eq 'blib'      ) ? 'object' :
        ($generic eq 'file' && basename($filename) eq 'pm_to_blib') ? 'object' :
        ($generic eq 'dir'  && -d "$filename/.git"                ) ? 'git'    :
                                                                     ''
    );

    if($generic eq 'link') {
        my $target = readlink($filename);
        if(!-e $target) {
            $generic .= 'broken'
        } else {
            my $target_type = get_icon_type_generic($target);
            $generic .= $target_type =~ /^(file|dir)$/ ? $target_type : '';
        }
    }
    state $map = {
        test       => '',
        text       => '',
        list       => '',
        tree       => 'פּ',
        lock       => '',
        perl       => '',
        vim        => '',
        c          => '',
        'c++'      => '',
        header     => '',
        object     => '',
        git        => '',
        ci         => '',
        apple      => '',

        dir        => '',
        link       => '',
        linkbroken => '',
        linkfile   => '',
        linkdir    => '',
        exec       => '',
        file       => '',
        pipe       => 'ﳣ',
        socket     => 'ﳦ',
        blockdev   => '',
        chardev    => '',
        ''         => ' ',
    };
    return join(' ', $map->{$generic}, $map->{$specific});
}

=encoding utf8

=head1 NAME

lls - a differently capable and much more configurable `ls`

=head1 SYNOPSIS

  $ lls [OPTIONS] [FILES]

=head1 DEPENDENCIES

A Unixy operating system.

You will need to install C<Nerd Font>. See its instructions on Github:
L<https://github.com/ryanoasis/nerd-fonts/blob/master/readme.md>.

You will then need to configure your terminal appropriately. If you use
iTerm on a Mac then see these instructions:
L<https://github.com/Peltoche/lsd/issues/199#issuecomment-494218334>.
If you are not using iTerm on a Mac then you are computering wrong.

=head1 OPTIONS

=over

=item -l | --long

Turns on all the available columns. Without any other options this will be the
same as C<ls -l> but with an extra column of icons before the filenames.

See also L</"DISPLAY OPTIONS">.

=item -a | --all

Show all directory entries. The default is to suppress any whose names
begin with a dot.

=item -A | --hidden

Show all directory entries except C<.> and C<..>. C<-a> over-rides this.

=item -I | --ignore FILE

Takes an argument, the name of a file to ignore. That file will not be
listed, including if a file with that name exists in a subdir and C<-R>
is in effect. To only ignore a specific file and not any other files with
the same name provide its fully qualified absolute path. If FILE begins with
a dot then any file with that extension will be ignored.

This option can be supplied many times.

As a special case, you can pass C<-I $FIGNORE> (that's the literal string
'$FIGNORE' - you'll probably have to escape the dollar sign). That will ignore
everything in the C<FIGNORE> environment variable.

=item -d | --dirs

If a directory name is given on the command line show its metadata, not
its contents.

In conjunction with C<-R> recurses into subdirs and only shows directories.

=item -r | --reverse

Reverse sort order

=item -t | --time

Sort output by modified-time

=item -S | --size

Sort output by size

=item -R | --recurse

Recurse into sub-directories. The output is very different from what C<ls> does.
Compare:

    $ ls -lR a
    total 0
    drwxr-xr-x  3 david  staff  102  2 Jul 12:44 b
    
    a/b:
    total 0
    drwxr-xr-x  3 david  staff  102  2 Jul 12:44 c
    
    a/b/c:
    total 0
    drwxr-xr-x  2 david  staff  68  2 Jul 12:44 d
    
    a/b/c/d:

and:

    $ lls -lR a
    drwxr-xr-x  3  david  staff  102 B 02 Jul 12:44    a
    drwxr-xr-x  3  david  staff  102 B 02 Jul 12:44    └─ b
    drwxr-xr-x  3  david  staff  102 B 02 Jul 12:44       └─ c
    drwxr-xr-x  2  david  staff   68 B 02 Jul 12:44          └─ d

=item --norecurse DIR

Takes an argument, the name of a directory to not recurse into even
when C<-R> is turned on. Like C<--ignore> can be either a name that
exists in any directory, or a fully-qualified name, and can be supplied
many times.

=item -g | --git (not yet implemented)

Include information on files' git status.

=item --noicons

Suppress icons output. Incompatible with C<--show_icons>.

=item -7 | --ascii

Suppress non-ASCII output. Implies C<--noicons>. If you ask for recursive
output the tree will be rendered in ASCII.

=item -8 | --utf8

Use Unicode (encoded as utf-8) for output. This is the default. Over-rides any
C<--ascii>, and does so before that has a chance to suppress icons.

=item -H | --HELP (all caps)

Show more help

=back

=head1 DISPLAY OPTIONS

The default with no options is to show files' icons and names in one long
list. With the
C<-l> option you get permissions, number of links, owner, group, size,
date/time, icons, and names. With the C<-R> option a tree will be added,
and with the C<-g> option git info will be added.

But it's a lot more configurable than that. If any of the following options
are present then all of the other display options will be turned off and C<-l>
will have no effect:

=over

=item --show_icons

Show the icons for a file

=item --show_name

Show the filename

=item --show_perms

Show the read/write/execute permissions and file type

=item --show_links

Show the number of links to the file

=item --show_owner

Show the file's owner

=item --show_group

Show the file's group

=item --show_size

Show the file's size. NB that this is shown as the number of
bytes/KiB/MiB/GiB/TiB.

=item --show_date

Show the file's last modified date/time.

=back

=head1 FILES

Default arguments will be read from C<~/.config/lls/args> if it exists.
Platform-specific arguments will be read from C<~/.config/lls/${platform}_args>
if it exists.
